---
layout: post
title: 15. 아키텍처란?
date: 2023-06-10 21:00:00 +0900
categories: "Clean Architecture"
author: hojunee
---
# 15. 아키텍처란?

## Architecture와 Architect

Disclaimer: Software Architect도 결국은 **프로그래머**다

- 고수준 문제에만 집중? NO!
- 생산성을 극대화할 수 있는 설계를 하도록 방향을 지도
- Why programming? → 발생하는 문제를 직접 경험해보지 않는다면 다른 프로그래머를 지원하는 작업을 제대로 수행할 수 없기 때문!

SW시스템의 아키텍처란? 시스템을 구축했던 사람들이 만들어낸 시스템의 형태

- 시스템을 컴포넌트로 **분할**하는 방법
- 분할된 컴포넌트를 **배치**하는 방법
- 컴포넌트가 서로 **의사소통**하는 방법

> 가능한 한 많은 선택지를 가능한 오래 남겨두는 전략을 취해야한다.
> 

시스템 아키텍처는 시스템의 동작 여부와는 거의 **관련이 없다.**

- 운영보다는 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪게 된다.
- 아키텍처가 시스템을 제대로 동작하도록 지원하는 데에 역할이 있긴 하지만, 이것은 수동적이며 피상적이다.

아키텍처의 주된 목적은 **시스템의 생명주기**를 지원하는 것

- 좋은 아키텍처는 시스템을 쉽게 이해하고, 개발하고, 유지보수하고, 배포하게 해준다
- 시스템의 수명과 관련된 비용은 Down, 프로그래머의 생산성은 Up

---

## 개발

시스템 아키텍처는 개발팀이 **시스템을 쉽게 개발할 수 있도록** 뒷받침해야만 한다

- Case 1: 개발자가 5명이라면? → Monolithic System을 개발할 수도 있다
- Case 2: 5팀 X 개발자 7명 → 신뢰할 수 있도 안정된 인터페이스를 갖춘 잘 설계된 컴포넌트 구분이 필요
    - 만약 없다면? 각 컴포넌트가 제각각 발전하는 형태로 진행 → 비호율적!

## 배포

**배포 비용이 높을수록 시스템의 유용성은 떨어진다.**

- 따라서 소프트웨어 아키텐처는 시스템을 단 한번에 쉽게 배포할 수 있도록 만들어야함

## 운영

아키텍처가 시스템 운영에 미치는 영향은 다른 것들에 비해 상대적으론 미미한 편

- 하드웨어를 더 투입해서 해결할 수 있기 때문. 하지만 비용 발생!

좋은 아키텍처는 시스템을 운영하는 데 **필요한 요구**도 알려준다.

- 시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내준다.
- How? 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상
    - 주요 목표로 인식 → 시스템을 이해하기 쉬워짐

## 유지보수

유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 발생

- 새로운 기능 추가
- 이에 수반되는 여러 결함들을 수정
- **탐사**와 이로 인한 위험부담 발생
    - 어디를 고치는게 최선일까?
    - 어떤 전략을 쓰는게 최적일까?
    - …

좋은 아키텍처는 이 비용을 크게 줄일 수 있다.

- e.g. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리

---

## 가능성 열어두기

소프트웨어의 가치?

- 행위적 가치
- 구조적 가치 - 소프트웨어를 “소프트” 하게!
- 어떻게하면 **Soft**ware를 만들 수 있을까?
    - 중요하지 않은 세부사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두기

소프트웨어 시스템의 구성

- 정책(policy): 모든 업무 규칙과 업무 절차를 구체화
- 세부사항(detail) : 사람, 외부 시스템, 프로그래머와 정책 사이의 소통요소 등
    - e.g. I/O 장치, DB, Framework, …

> 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다
> 

→ 세부사항을 결정하는 일은 미루거나 연기할 수 있게 됨

예를 들어, 개발 초기에는…

- DB 시스템을 선택할 필요가 없다
    - 고수준의 정책은 어떤 종류의 DB를 사용하는 지 신경 써서는 안됨
    - 분산형? 계층형? Whatever!
- 웹 서버를 선택할 필요가 없다
    - 자신이 웹을 통해 전달된다는 사실을 알아선 안된다
        - 고수준이 HTML, AJAX, JSF 등의 기술을 아는 것은 중요하지 않다
        - 심지어 시스템이 웹을 통해 전송되는지도 결정할 필요가 없다
- REST를 적용할 필요가 없다, MSA, SOA또한 마찬가지다
    - 외부 세계로의 인터페이스에 대해 독립적이여야함
- DI(Dependency Injection) 프레임워크를 적용할 필요가 없다
    - 고수준의 정책은 의존성을 해석하는 방식에 대해 신경 써서는 안된다

*TL;DR: 시스템에서 정책에 집중하고, 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축해야 한다.*

---

## 결론

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다
- 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다
- 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다