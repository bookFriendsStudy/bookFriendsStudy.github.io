---
layout: post
title: 14. 컴포넌트 결합
date: 2023-06-03 21:00:00 +0900
categories:
- Clean Architecture
author: jjonyo
---

# 14장

# 14장 컴포넌트 결합

## ADP: 의존성 비순환 원칙

<aside>
💡 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.

</aside>

많은 개발자가 동일한 소스 파일을 수정하는 환경에서 내가 의존하고 있는 무언가가 수정되어 작동하던 프로그램이 작동하지 않을 수 있다. 이를 **숙취 증후군** 이라고 한다

이 문제의 해결책으로는 크게 두가지 방법이 있다.

### 주 단위 빌드 (Weekly Build)

- 5일중 4일은 서로를 신경쓰지 않고 개발한다. 이때, 코드를 어떻게 통합할지는 걱정하지 않는다.
- 그리고 마지막 날에 코드 통합에 관련된 일을 한다.

하지만, 프로젝트가 커지면 통합하는 일은 하루만에 끝나지 않을 수 있다.

결국, 통합에 드는 시간이 늘어나며 팀의 효율성이 서서히 나빠지게 된다.

### 순환 의존성 제거하기

- 개발환경을 릴리즈 가능한 컴포넌트 단위로 분리한다.
- 컴포넌트는 개별 개발자 또는 개발팀이 책임질 수 있는 개발단위가 된다.
- 컴포넌트를 동작할 수 있게끔 만든다음 릴리즈하여 다른 개발자가 사용할 수 있게 한다.
- 각 개발자는 자신의 컴포넌트만 지속적으로 수정한다. 다른 컴포넌트가 새로 릴리즈 되어도, 새 릴리즈를 적용할지 말지 선택할 수 있다.
- **즉, 컴포넌트의 변경이 다른팀에 즉각 영향을 주지 않는다!**

이 절차가 성공적으로 동작하려면 컴포넌트 사이의 **의존성 구조**를 관리해야한다.

의존성 구조에 순환이 있어서는 안 된다.


위 컴포넌트를 각각의 팀이라 생각해보자.

- Presenters가 새로 릴리즈 되었다.
- 이를 의존하는 컴포넌트는 View와 Main이다.
- View와 Main의 담당자는 Presenters의 새로운 릴리즈를 통합할지 결정하면 된다.
- 또한 만약 Presenters 컴포넌트를 테스트하고자 한다면, 이 컴포넌트가 의존하고 있는 Interactors와 Entities만 이용하면 된다. 다른 컴포넌트와는 전혀 관련이 없다.
- Main컴포넌트는 어떠한 컴포넌트도 의존하고 있지 않으므로 영향을 받는 컴포넌트가 없다. 따라서 Main을 릴리스 함으로써 미치게 되는 충격은 대체로 작다.

만약 시스템 전체를 릴리즈 해야 한다면, 릴리즈 절차를 상향식으로 진행하면 된다.

`Entities -> Database,Interactors -> Presenter, View, Controllers, Authorizer ->Main`

### 순환이 컴포넌트 의존성 그래프에 미치는 영향


Entities에서 Authorizer를 의존하고 있다.

Authroizer는 Interactors를 의존하고 이는 Entities를 의존한다.

**즉, 의존성의 순환이 발생했다 !!**

이 상황에서 만약 Database컴포넌트를 릴리즈해야 한다면,

Entities, Authorizer, Interactors 사이에 순환이 발생하므로 릴리즈 하기가 어려워진다.

또한, 만약 Entities를 테스트해야한다면 Interactors와 Authorizer도 함께 빌드해야 한다.

### 순환 끊기

이러한 컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 복구하는 방법이 있다.

- 의존성 역전 원칙 적용


Entities에서 Authorizer에서 필요로 하던 기능을 제공하는 인터페이스를 생성한다.

Entities에서는 내부에 있는 인터페이스를 의존하며, Authoizer에서 이를 구현한다.

이렇게하면 Entities가 Authoizer를 의존하지 않고 독립적으로 빌드, 테스트하는것이 가능해진다.

- 새로운 컴포넌트 만들기


두 컴포넌트가 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

즉, 기존에 Entities처럼 아무것도 의존하지 않는 컴포넌트를 새로 만들어줌으로써 DAG로 복구한다.

## SDP: 안정된 의존성 원칙

설계를 유지하다보면 변경은 불가피하다. 

우리가 만드는 컴포넌트 중 일부는 언젠가 변경되리라 예상하며 변동성을 지니도록 설계한다.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 안된다.

이렇게된다면, 변동성이 큰 컴포넌트도 결국 변경하기가 어려워진다.

내가 모듈을 만들땐, 변경하기 쉽도록 설계했을지라도 이 모듈에 누군가 의존성을 매달아버리면 이 모듈도 변경하기 어려워진다. 어느순간 모듈을 변경하는 일이 상당히 도전적인 일이 되어버린다.

**안정된 의존성 원칙**을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안정성이란?

컴포넌트를 변경하기 어렵게 만드는 확실한 방법은 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.

그렇다면 의존하는 컴포넌트들로 인해 변경하는것이 어려워지고, 소프트웨어에서는 이처럼 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 안정적이라고 본다. (사소한 변경이라도 모든 컴포넌트를 만족시키며 변경하는건 상당한 노력이 들기때문)


즉, 위 X는 세 컴포넌트가 의존하고 있으므로 변경되지 말아야할 이유가 세 가지나 된다.

이때 X를 안정된 컴포넌트라고 한다.


반대로 Y는 불안정한 컴포넌트다.

세개의 컴포넌트를 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지이다.

→ 변경될 가능성이 적으면 안정적이다.

### 안정성 지표

컴포넌트가 위치상 어느정도의 안정성을 가지는지 계산할 수 있다.

컴포넌트로 들어오고, 나가는 의존성 개수를 세어보면 된다.

- Fan-in : 나를 의존하는 외부 컴포넌트 클래스 개수
- Fan-out : 외부를 의존하는 컴포넌트 클래수 개수
- 불안정성 : Fan-out / (Fan-in + Fan-out)
    - 0,1 범위의 값을 가지며 0이면 최고로 안정된 컴포넌트다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다.

모든 컴포넌트가 최고로 안정적이라면 곧 변경이 불가능하다는 것을 의미한다.

이상적인 구조는 다음과 같다.


불안정한 컴포넌트는 안정적인 컴포넌트를 의존해야 한다.

 

## SAP: 안정된 추상화 원칙

컴포넌트는 안정된 정도만큼만 추상화 되어야 한다.

- 안정된 컴포넌트는 추상 컴포넌트여야 한다.
- 불안정한 컴포넌트는 구체 컴포넌트여야 한다.
    - 불안정하기 때문 내부의 구체적인 코드를 쉽게 변경할 수 있어야 한다.

우리가 이전에 배웠던 템플릿메소드 패턴이 이 원칙을 지키는것 같다.

인터페이스, 추상 클래스 = 변하면 안되는것

구체 클래스 = 변하는것

### 추상화 정도

`인터페이스(추상클래스) 개수 / 클래스 개수`

로 추상화 정도를 측정할 수 있다.

그리고 안정성과 추상화 정도를 그래프로 표현해보자.


고통의 구역과 쓸모없는 구역을 피해 가운데 있는 주계열에 적절하게 위치하는게 가장 이상적이다. 주계열과의 거리를 계산하여 설계가 어떠한지도 분석할 수 있다.

이를 통해 설계를 통계적으로 분석하는 일도 가능해진다.

## 결론

- 의존성 관리지표를 통해 설계의 의존성과 추상화정도가 내가 `훌륭한 패턴` 이라고 생각하는 수준에 얼마나 잘 부합하는지 측정할 수 있다.
- 그러나, 지표는 신이 아니다. 임의로 결정된 표준을 기초로한 측정값이다. 지표로 부터 유용한 것을 잘 골라내자.

- 안정성이나, 추상화정도 등 그동안 디자인패턴이나, 자연스럽게 알고 있던 것들을 이론으로 정의내려준것 같았다.