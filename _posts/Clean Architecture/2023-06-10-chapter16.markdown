---
layout: post
title: 16. 독립성
date: 2023-06-10 21:00:00 +0900
categories:
- Clean Architecture
author: hojunee
---
# 16. 독립성

## 좋은 아키텍처가 고려해야 할 것은?

- 유스케이스
- 운영
- 개발
- 배포

## 유스케이스

아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다.

하지만, 좋은 아키텍처가 행위를 지원하기 위해:

- 행위를 명확히 하고 외부로 드러낸다
- 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만든다.

시스템 아키텍처는 **시스템의 의도**를 지원해야 한다

- e.g. 시스템이 장바구니 애플리케이션이라면?
    - 이 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 함!
- 만약 좋은 아키텍처를 가졌다면?
    - 시스템 구조에서 이를 한눈에 알아볼 수 있다
        - 일급 요소이며 시스템의 최상위 수준에서 알아볼 수 있음
        - 클래스, 함수, 모듈로서 아키텍처 내에서 핵심적인 자리를 차지하며, 기능을 분명하게 설명하는 이름을 가짐
    

## 운영

운영 지원 관점에서 아키텍처는 실질적인 역할을 담당

- e.g. 시스템이 100,000 user/sec를 감당해야 한다면?
    - 이 요구와 관련된 처리량과 응답시간을 보장해야함!
- e.g. 시스템에서 X ms 안에 3D 빅데이터 테이블에 쿼리를 보내야한다면?
    - 이를 허용하는 형태로 아키텍처를 구조화햐아 함!

운영 지원은 시스템의 상황에 맞게 변한다

- 병렬 실행이 가능한 구조
- 수많은 경량 스레드가 단일 프로세서에서 같은 주소 공간을 공유
- 소수의 프로세스가 독립된 주소 공간에서 실행되는 구조
- …

 

이를 위한 결정은 열어두어야 하는 **선택사항**이다.

- 모노리틱 구조를 가진 상황에서 다중 프로세스, 다중 스레드, 혹은 마이크로서비스가 필요하다면? 😢
- 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 유연하게 대처가 가능해짐

## 개발

콘 웨이의 법칙을 고려할 필요가 있음:

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 **동일한** 구조의 설계를 만들어 낼 것이다.
> 
- 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보 → 개발하는 동안 팀들이 서로 방해하지 않도록 해야 함
- 이러한 아키텍처를 만들기 위해선 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 함

## 배포

좋은 아키텍처는:

- 수십 개의 작은 설정 스크립트나 속성 파일을 약간 수정하는 방식을 사용하지 않음
- 꼭 필요한 디렉터리나 파일을 수작업으로 생성하도록 하지 않음
- 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 함

마스터 컴포넌트와 컴포넌트를 적절하게 분할하고 격리하여 **즉각적인 배포**를 위해 노력해야 함

---

## 선택사항 열어놓기

현실적으로, 이 위의 주제들 간의 균형을 잡는 것은 굉장히 어렵다

- 모든 유스케이스를 알기 어려움
- 제약사항, 팀 구조, 배포 요구사항을 한번에 파악하는 것은 어려움
- 심지어, 이런 것들은 시스템의 생명주기에 따라 반드시 변함
- 몇몇 아키텍처 원칙은 이를 해결하는 데에 도움이 된다

### 계층 결합 분리

- 아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지는 못함
- 하지만,아키텍트는 시스템의 기본적인 의도(장바구니? 주문 처리 시스템? 등)은 알고있음.
- 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여 의도의 맥락을 구분
    - 다른 이유로 변경되는 것은 분리!
    - 동일 이유로 변경되는 것은 통합!

업무 규칙은 그 자체가 App과 밀접한 관련이 있거나,혹은 더 범용적일 수 있음

- 애플리케이션과 연관된 것:
    - e.g. 입력 필드의 유효성 검사
- 업무 도메인과 연관된 것:
    - e.g. 계좌의 이자 계산
    - e.g. 재고품 집계

이들은 각자 다른 이유와 속도로 변경될 것임 → 이를 분리하고 **독립적**으로 변경할 수 있어야 함

- UI, 업무 로직, DB, …

### 유스케이스 결합 분리

유스케이스 그 자체도 서로 다른 이유로 변경된다.

e.g. 주문 시스템에서의:

- 주문 추가 유스케이스
- 주문 삭제 유스케이스

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab608fc2-6cdb-403c-8318-79abc2c193b9/Untitled.png)

- 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적 유스케이스로 시스템을 분할할 수 있다.
- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스 추가 가능!

### 개발 독립성

- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다

### 배포 독립성

- 유스케이스와 계층의 결합이 분리되면 배포에서의 유연성을 가져갈 수 있다
- hotswap을 진행할 수 있고, 새로운 유스케이스는 새로운 컴포넌트 추가 등으로 쉽게 해결할 수 있다

### 중복

소프트웨어에서 중복은 일반적으로 나쁜것임.

- 진짜 중복
    - 한 인스턴스가 변경되면 이 변경사항을 복사본에 모두 적용해야함
- 가짜 or 우연에 의한 중복
    - 비슷해보이는 코드이나 각자의 경로로 발전할 가능성이 있음
    - 이러한 경우라면 해당 코드를 통합하지 않도록 유의해야 함

유스케이스 간의 비교에서 위를 감안하여 통합하고자 하는 **유혹**을 잘 견디자

- 중복이 진짜 중복일까?

### 결합 분리 모드

- 유스케이스를 분리하면 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스가 분리됨 → 이에 따라서 각각에 적합한 전략을 취할 수 있다.

계층과 유스케이스의 결합을 분리하는 방법은 다양하다:

- 소스 수준 분리
    - 소스 코드 모듈 사이의 의존성 제어 → 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있음
    - e.g. 루비 Gem
- 배포 수준 분리
    - 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음
    - 결합이 분리된 컴포넌트가 jar, Gem, DLL과 같이 독립적으로 배포할 수 있는 단위로 분할됨
    - e.g. jar 파일, DLL, 공유 라이브러리
- 서비스 수준 분리
    - 의존 수준을 데이터 구조 단위까지 낮추어, 네트워크를 통해서만 통신하도록 만들 수 있음
    - 소스와 바이너리 변경에 대해서 서로 완전히 독립적이게 됨
    - e.g. 서비스, 마이크로 서비스
    

최근에는 단순한 서비스 수준에서의 분리를 기본 정책으로 가져가는 것이 인기임 (MSA?)

- 비용이 많이 들고, 결합이 큰 단위에서 분리된다는 문제가 있음
- 시스템 자원 측면에서 비용을 많이 소요함

좋은 아키텍처는 상황에 맞게 이를 선택하여 구조를 구성해야 함

- 심지어는… Scale을 키우다가라도 모노리틱 구조로 되돌릴 수 있어야 함

---

## 결론

이렇게 하는 것은 매우 까다롭지만…

뛰어난 아키텍트라면 이러한 상황 변경을 예측해서 큰 무리 없이 반영할 수 있어야 한다!