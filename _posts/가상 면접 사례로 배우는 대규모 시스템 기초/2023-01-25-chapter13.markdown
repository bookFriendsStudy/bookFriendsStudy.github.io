---
layout: post
title: 13. 검색어 자동완성 시스템
date: 2023-01-25 21:00:00 +0900
categories:
- 가상 면접 사례로 배우는 대규모 시스템 기초
author: hojunee
---
# 13. 검색어 자동완성 시스템

## Goal

어떤 쿼리 `q` 를 입력했을 때, 이와 관련하여 가장 많이 검색된 검색어 `k`개 표현하기

### 1. 문제 이해 및 설계 범위 확정

적절한 질문을 통해 요구사항을 분명히 하자

- 사용자가 입력하는 단어는 자동완성 검색어의 첫부분 (prefix)
- 5개의 자동완성 검색어가 표시되어야 한다
- 질의 빈도를 기반으로 한 검색어 인기 순위를 기준으로 함
- 질의는 영어(en-US)로 하되, 다국어도 염두해두면 좋다
- 모든 질의는 소문자로 이루어진다고 가정
- DAU 10 Million정도를 처리할 수 있어야함

이로부터 우리는 설계의 요구 디테일을 확인할 수 있다

- 빠른 응답 속도
- 연관성
- 정렬
- 규모 확장성
- 고가용성

**개략적 규모 측정**

- 일간 능동 사용자(DAU)는 10M 명정도로 가정
- 평균적으로 한 사용자당 10 Query  / Day 입력
- 평균적으로 질의는 20Byte의 데이터로 입력됨 → 왜?
    - ASCII (← en-US), 1Byte
    - 4개의 단어로 이루어진다고 가정, 각 단어는 5글자
    - 따라서 4 * 5 = 20Byte

## 2. 개략적 설계안 제시 및 동의 구하기

이 시스템은 크게 2가지 부분으로 구분할 수 있음

- 데이터 수집 서비스
    - 사용자가 입력한 질의를 실시간으로 수집하는 시스템
- 질의 서비스
    - 주어진 질의에 대해 5개의 인기 검색어를 정렬해서 내놓는 서비스
    

### 데이터 수집 서비스

주어진 쿼리에 대해서 어떻게 빈도 데이터를 수집할 것인가?

### 질의 서비스

빈도 테이블이 있는 상황에서 어떻게 하면 우리가 원하는 rank 기반 데이터를 가져올 것인가?

위 두 경우를 모두 최적화하는 것을 목표로 해보자

## 3. 상세 설계

### Trie(트라이)

- 트리 형태의 자료구조
- 이 트리의 루트 노트는 빈 문자열을 나타낸다
- 각 노드는 글자 하나를 저장하며, at most 26개의 자식 노드를 가질 수 있다
- 각 트리 노드는 하나의 단어 or 접두어 문자열(prefix string)을 나타냄

이 정보를 **빈도 테이블**과 결합하면 다음과 같이 작성할 수 있다

이를 활용하면, 트라이에서 다음과 같이 자동완성을 구현할 수 있다.

1. 해당 접두어 노드를 찾는다
2. 해당 노드부터 시작하는 하위 트리를 탐색해서 모든 유효 노드를 찾는다
3. 유효 노드를 정렬하여 `k`개를 골라낸 후 반환한다.

이 알고리즘은 직관적이지만 최악의 경우에 대해서 `k` 개의 결과를 얻기 위해서 전체 트라이를 다 검색해야 하는 경우가 있다.

다음 두 가지 해결방안을 접목해보자:

**접두어의 최대 길이를 제한**

사용자가 검색창에 긴 검색어를 검색할 일은 없으므로, `p` 값을 작은 정수화(e.g. 50) 하여 상수화할 수 있다.

**각 노드에 인기 검색어를 캐시**

각 노드에 `k` 개의 인기 검색어를 저장해두면 전체 트라이를 검색하는 일을 방지할 수 있다.

→ 접두어 노드를 찾는 시간 복잡도는 O(1)으로 변경

→ 최고 인기 검색어 `k` 개를 찾는 질의의 시간 복잡도도 O(1)으로 변경된다

### 데이터 수집 서비스

사실, 실시간으로 타이핑이 일어날 때마다 데이터를 실시간으로 수정하는 것은 실용하지 못하다.

- 매일 수천만 건의 질의에 대응하여 Trie를 업데이트하는 것은 엄청난 자원이 소모된다
- 일단 트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것임 → 트라이는 자주 갱신할 편이 없다

(+ Twitter와 같은 실시간 Application이 아닌, Google Search와 같은 Application임을 가정)

**데이터 분석 서비스 로그**

검색창에 입력된 질의에 관한 원본 데이터 보관

**로그 취합 서버**

Application의 성격에 따라서 데이터 취합 주기를 변경하면서 로그를 취합

**작업 서버**

트라이 자려구조를 만들고 데이터를 트라이 DB에 저장

**트리이 캐시**

분산 캐시 시스템으로, 읽기 연산 속도를 향상

**트라이 데이터베이스**

- 문서 저장소
- 키-값 저장소

### 질의 서비스

1. 검색 질의가 로드밸런서로 전송
2. 로드밸런서는 해당 질의를 API 서버로 보냄
3. API 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성
4. 데이터가 캐시에 없는 경우는 데이터를 데이터베이스에서 가져와 캐시를 갱신

질의 서비스의 속도를 향상시키기 위한 전략으로는 두가지가 있음

- AJAX 요청
    - 비동기적으로 요청을 처리해서 페이지를 새로고침할 필요를 없도록 만들자
- 브라우저 캐싱
    - 자동완성의 결과가 드라마틱하게 바뀌지 않으므로, 제안된 검색어들을 브라우저에 캐시에 넣어두자
- 데이터 샘플링
    - 모든 요청을 굳이 로깅할 필요는 없고, 주어진 데이터들 중에서 임의의 subset에 대해서만 이를 진행하자

### 트라이 연산

작업 서버가 트라이를 생성하고, 데이터 분석 서비스의 로그나 DB로부터 취합된 데이터를 이용

**트라이 갱신**

- 매주 한번 갱신하기, 새로 Build한 후 기존 Trie를 대체한다
- 트라이의 각 노드를 개별적으로 갱신 (→성능이 썩 좋진 않으나, 크기가 작을 경우에는 고려해봄직함)

**검색어 삭제**

혐오성이 짙거나 폭력성이 높은 컨텐츠 등은 필터링 할 필요가 있으므로, 필터 레이어(filter layer)를 추가할 수도 있음

**저장소 규모 확장**

- 트라이의 크기가 한 서버에 넣기엔 너무 클 수 있다. 이러한 경우라면 **샤딩** 등을 통해서 이 문제를 해결할 수 있다.
- 단순하게 사전순으로 이를 정렬할 수도 있고, 검색어 대응 샤드 관리자를 도입해서 어느 샤드에 해당 데이터가 존재하는지를 체크 후 데이터를 추출할 수도 있다

### 4. 마무리

다음 질문들도 예상이 가능하다

- 다국어 지원이 가능하도록 시스템을 확장하려면?
- 국가별로 인기 검색어 순위가 다르다면?
- 실시간으로 변하는 검색어의 추이를 반영하려면?